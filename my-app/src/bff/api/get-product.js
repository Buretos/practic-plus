import { transformProduct } from '../transformers';
// Сначала смотрим есть ли статья. В случае отстуствия статьи по заданному адресу команда fetch выдаёт промис успешного запроса, который обрабатывается обычным .then. Т.е. ошибка 300-х и 400-х ответов это не ошибка запроса сервера (когда, например сервер не ответил), а ошибка контента данных на серевре. Сервер же успешно обработал запрос. Так ошибка 404 (статья не найдена) обрабатывается через then, а не через catch.
export const getProduct = async (productId) =>
	fetch(`http://localhost:3005/products/${productId}`)
		.then((res) => {
			// Проверяем ответ сервера. Если сстатус ответа .ok, то отправляем овтет так как нет ошибок. Иначе обрабатываем ошибку. Если статус ответа соответствует 404 (данные не найдены), то признаём негодным промис ответа Promise.reject('...') с сообщением 'Такая страница не существует'.  Promise.reject('...') уже можно обработать в catch. Если другие ошибки (не 404, а ошибки есть, т.к. нет статуса ответа ok), то указываем на них в обобщённом виде: 'Что-то пошло не так. Попробуйте ещё раз позднее'
			if (res.ok) {
				return res;
			}

			const error =
				res.status === 404
					? 'Такая страница не существует'
					: 'Что-то пошло не так. Попробуйте ещё раз позднее';
			// Возвращаем (прокидываем) Promise.reject, значит можем принять его и обработать в catch (наприммер в fetch-product, откуда был запрос сюда). Но там мы запрашивали через async/await. Ошибки будут обрабатываться не через then/catch, a через try/catch.
			return Promise.reject(error);
		})
		.then((loadedProduct) => loadedProduct.json())
		.then((loadedProduct) => loadedProduct && transformProduct(loadedProduct));
